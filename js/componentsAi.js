// Generated by CoffeeScript 2.2.3
var actSocket, botAvatar, componentMessage, componentMessageEvent, componentMessageMatch, componentMessageSend, onMessageTask, receiveBot, receiveUser, strSocket, telegram, userAvatar;

botAvatar = 'https://robohash.org/liberovelitdolores.bmp?size=50x50&set=set1';

userAvatar = 'http://icons.iconarchive.com/icons/visualpharm/must-have/256/User-icon.png';

telegram = new Vue({
  el: '#telegram',
  data: {
    botSleep: 1000,
    textfield: '',
    users: [
      {
        avatar: botAvatar,
        username: 'Halmstad'
      },
      {
        avatar: userAvatar,
        username: 'Wako',
        owner: true
      }
    ],
    messages: [
      {
        user: 0,
        text: 'Hello, I\'m a bot in a Messenger. I can be programmed without writing any code. Just use the node editor on the left'
      },
      {
        user: 0,
        text: 'This example is a demonstration of [d3-node-editor](https://github.com/Ni55aN/d3-node-editor) library. Based on it you can make your powerful editor'
      },
      {
        user: 0,
        text: 'If you like the project, you can [support it](https://github.com/Ni55aN/d3-node-editor#donate)'
      }
    ]
  },
  methods: {
    formatMsg: function(msg) {
      return msg.replace(/\[(.+?)\]\((.+?)\)/g, '<a target="_blank" href="$2">$1</a>');
    },
    onMessage: function() {
      var ms;
      ms = this.$refs.messages;
      return delay(100, () => {
        return ms.scrollTop = ms.scrollHeight;
      });
    },
    sendOwner: function(message) {
      this.messages.push({
        user: 1,
        text: message
      });
      receiveBot(message);
      return this.onMessage();
    },
    sendBot: function(message) {
      this.messages.push({
        user: 0,
        text: message
      });
      return this.onMessage();
    }
  }
});

onMessageTask = null;

receiveBot = function(msg) {
  return delay(telegram.botSleep, async() => {
    return (await onMessageTask.run(msg));
  });
};

receiveUser = function(msg) {
  return telegram.sendBot(msg);
};

actSocket = new D3NE.Socket('action', 'Action', 'hint');

strSocket = new D3NE.Socket('string', 'String', 'hint');

componentMessageEvent = new D3NE.Component('Message event', {
  builder: function(node) {
    var out1, out2;
    out1 = new D3NE.Output('Action', actSocket);
    out2 = new D3NE.Output('Text', strSocket);
    return node.addOutput(out1).addOutput(out2);
  },
  worker: function(node, inputs, outputs) {
    var task;
    task = (onMessageTask = new D3NE.Task(inputs, (inps, msg) => {
      return [msg];
    }));
    outputs[0] = task.option(0);
    return outputs[1] = task.output(0);
  }
});

componentMessageSend = new D3NE.Component('Message send', {
  builder: function(node) {
    var inp1, inp2;
    inp1 = new D3NE.Input('Action', actSocket);
    inp2 = new D3NE.Input('Text', strSocket);
    return node.addInput(inp1).addInput(inp2);
  },
  worker: function(node, inputs, outputs) {
    var task;
    return task = new D3NE.Task(inputs, (inps) => {
      var text;
      console.log(inps);
      text = inps[0] ? inps[0][0] : '...';
      //default text
      console.log('msg send');
      return receiveUser(text);
    });
  }
});

componentMessageMatch = new D3NE.Component('Message match', {
  builder: function(node) {
    var ctrl, inp1, inp2, out1, out2;
    inp1 = new D3NE.Input('Action', actSocket);
    inp2 = new D3NE.Input('Text', strSocket);
    out1 = new D3NE.Output('True', actSocket);
    out2 = new D3NE.Output('False', actSocket);
    ctrl = new D3NE.Control('<input>', (el, control) => {
      var text;
      text = control.getData('regexp') || '.*';
      el.value = text;
      control.putData('regexp', text);
      return el.addEventListener('change', () => {
        return control.putData('regexp', el.value);
      });
    });
    return node.addControl(ctrl).addInput(inp1).addInput(inp2).addOutput(out1).addOutput(out2);
  },
  worker: function(node, inputs, outputs) {
    var task;
    task = new D3NE.Task(inputs, (inps) => {
      var text;
      text = inps[0] ? inps[0][0] : '';
      if (!text.match(new RegExp(node.data.regexp, 'gi'))) {
        return task.closed = [0];
      } else {
        return task.closed = [1];
      }
    });
    outputs[0] = task.option(0);
    return outputs[1] = task.option(1);
  }
});

componentMessage = new D3NE.Component('Message', {
  builder: function(node) {
    var ctrl, out;
    out = new D3NE.Output('Text', strSocket);
    ctrl = new D3NE.Control('<input>', (el, control) => {
      var text;
      text = control.getData('text') || 'Some message..';
      el.value = text;
      control.putData('text', text);
      return el.addEventListener('change', () => {
        return control.putData('text', el.value);
      });
    });
    return node.addControl(ctrl).addOutput(out);
  },
  worker: function(node, inputs, outputs) {
    var task;
    task = new D3NE.Task(inputs, (inps) => {
      return [node.data.text];
    });
    return outputs[0] = task.output(0);
  }
});
